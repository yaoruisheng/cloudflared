diff --git a/ingress/origin_proxy.go b/ingress/origin_proxy.go
index 7371eac9..9015ed1a 100644
--- a/ingress/origin_proxy.go
+++ b/ingress/origin_proxy.go
@@ -6,10 +6,21 @@ import (
 	"fmt"
 	"net"
 	"net/http"
+	"bufio"
+	"strings"
+	"time"
+	"io"
 
 	"github.com/rs/zerolog"
 )
 
+// readWriteCloseWrapper
+type readWriteCloseWrapper struct {
+	io.Reader
+	io.Writer
+	io.Closer
+}
+
 // HTTPOriginProxy can be implemented by origin services that want to proxy http requests.
 type HTTPOriginProxy interface {
 	// RoundTripper is how cloudflared proxies eyeball requests to the actual origin services
@@ -55,6 +66,94 @@ func (o *httpService) RoundTrip(req *http.Request) (*http.Response, error) {
 		o.SetOriginServerName(req)
 	}
 
+	var conn net.Conn
+	var err error
+	isTailscale := strings.Contains(req.URL.Path, "ts2021") || strings.HasPrefix(req.URL.Path, "/derp")
+	if isTailscale {
+		dialTimeout := o.transport.TLSHandshakeTimeout
+		if dialTimeout == 0 {
+			dialTimeout = 30 * time.Second
+		}
+		dialer := &net.Dialer{Timeout: dialTimeout, KeepAlive: 30 * time.Second}
+		if o.url.Scheme == "unix" {
+			conn, err = dialer.DialContext(req.Context(), "unix", o.url.Path)
+		} else {
+			targetAddr := req.URL.Host
+			if !strings.Contains(targetAddr, ":") {
+				if o.url.Scheme == "https" || o.url.Scheme == "wss" {
+					targetAddr = net.JoinHostPort(targetAddr, "443")
+				} else {
+					targetAddr = net.JoinHostPort(targetAddr, "80")
+				}
+			}
+			conn, err = dialer.DialContext(req.Context(), "tcp", targetAddr)
+		}
+		if err != nil {
+			return nil, err
+		}
+
+		var backendConn net.Conn = conn
+		if o.url.Scheme == "https" || o.url.Scheme == "wss" {
+			tlsConfig := &tls.Config{
+				RootCAs:            o.transport.TLSClientConfig.RootCAs,
+				InsecureSkipVerify: o.transport.TLSClientConfig.InsecureSkipVerify,
+				ServerName:         req.Host,
+			}
+			tlsConn := tls.Client(conn, tlsConfig)
+			if err := tlsConn.Handshake(); err != nil {
+				conn.Close()
+				return nil, err
+			}
+			backendConn = tlsConn
+		}
+
+		// 补偿请求 Header
+		if strings.Contains(req.URL.Path, "ts2021") {
+			req.Header.Set("Upgrade", "tailscale-control-protocol")
+		} else {
+			req.Header.Set("Upgrade", "websocket")
+		}
+		req.Header.Set("Connection", "Upgrade")
+
+		// 物理写入
+		if err := req.Write(backendConn); err != nil {
+			backendConn.Close()
+			return nil, err
+		}
+
+		// 读取响应
+		br := bufio.NewReader(backendConn)
+		resp, err := http.ReadResponse(br, req)
+		if err != nil {
+			backendConn.Close()
+			return nil, err
+		}
+
+		// 补偿响应 Header
+		if resp.StatusCode == http.StatusSwitchingProtocols {
+			if resp.Header.Get("Upgrade") == "" {
+				if strings.Contains(req.URL.Path, "ts2021") {
+					resp.Header.Set("Upgrade", "tailscale-control-protocol")
+				} else {
+					resp.Header.Set("Upgrade", "websocket")
+				}
+			}
+			if resp.Header.Get("Connection") == "" {
+				resp.Header.Set("Connection", "Upgrade")
+			}
+		}
+
+		resp.Close = false
+		resp.ContentLength = -1
+		resp.Header.Del("Content-Length")
+		resp.Body = &readWriteCloseWrapper{
+			Reader: br,
+			Writer: backendConn,
+			Closer: backendConn,
+		}
+		return resp, nil
+	}
+
 	return o.transport.RoundTrip(req)
 }
 
