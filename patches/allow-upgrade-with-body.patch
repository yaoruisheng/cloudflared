diff --git a/ingress/origin_proxy.go b/ingress/origin_proxy.go
index 7371eac9..f102b58a 100644
--- a/ingress/origin_proxy.go
+++ b/ingress/origin_proxy.go
@@ -6,10 +6,21 @@ import (
 	"fmt"
 	"net"
 	"net/http"
+	"bufio"
+	"io"
+	"strings"
+	"time"
 
 	"github.com/rs/zerolog"
 )
 
+// readWriteCloseWrapper
+type readWriteCloseWrapper struct {
+	io.Reader
+	io.Writer
+	io.Closer
+}
+
 // HTTPOriginProxy can be implemented by origin services that want to proxy http requests.
 type HTTPOriginProxy interface {
 	// RoundTripper is how cloudflared proxies eyeball requests to the actual origin services
@@ -55,6 +66,103 @@ func (o *httpService) RoundTrip(req *http.Request) (*http.Response, error) {
 		o.SetOriginServerName(req)
 	}
 
+	isTailscale := strings.Contains(req.URL.Path, "ts2021") || strings.HasPrefix(req.URL.Path, "/derp")
+
+	if isTailscale {
+		dialTimeout := o.transport.TLSHandshakeTimeout
+		if dialTimeout == 0 {
+			dialTimeout = 30 * time.Second
+		}
+		dialer := &net.Dialer{Timeout: dialTimeout, KeepAlive: 30 * time.Second}
+
+		var conn net.Conn
+		var err error
+
+		// 支持 Unix Socket 或 TCP 拨号到后端 Headscale
+		if o.url.Scheme == "unix" {
+			conn, err = dialer.DialContext(req.Context(), "unix", o.url.Path)
+		} else {
+			targetAddr := req.URL.Host
+			if !strings.Contains(targetAddr, ":") {
+				if o.url.Scheme == "https" || o.url.Scheme == "wss" {
+					targetAddr = net.JoinHostPort(targetAddr, "443")
+				} else {
+					targetAddr = net.JoinHostPort(targetAddr, "80")
+				}
+			}
+			conn, err = dialer.DialContext(req.Context(), "tcp", targetAddr)
+		}
+		if err != nil {
+			return nil, err
+		}
+
+		var backendConn net.Conn = conn
+		// 如果后端是 HTTPS，手动完成握手，避免流量在加密层死掉
+		if o.url.Scheme == "https" || o.url.Scheme == "wss" {
+			tlsConfig := &tls.Config{
+				RootCAs:		o.transport.TLSClientConfig.RootCAs,
+				InsecureSkipVerify:	o.transport.TLSClientConfig.InsecureSkipVerify,
+				ServerName:		req.Host,
+			}
+			tlsConn := tls.Client(conn, tlsConfig)
+			if err := tlsConn.Handshake(); err != nil {
+				conn.Close()
+				return nil, err
+			}
+			backendConn = tlsConn
+		}
+
+		// 资源清理：绑定 Context，确保客户端断开时释放后端连接
+		ctx := req.Context()
+		go func() {
+			<-ctx.Done()
+			backendConn.Close()
+		}()
+
+		// 强制修复被 Cloudflare 砍掉或修改的 Upgrade Header
+		if strings.Contains(req.URL.Path, "ts2021") {
+			req.Header.Set("Upgrade", "tailscale-control-protocol")
+		} else {
+			if req.Header.Get("Upgrade") == "" {
+				req.Header.Set("Upgrade", "websocket")
+			}
+		}
+		req.Header.Set("Connection", "Upgrade")
+
+		// 补全 WebSocket 握手必须的 Key/Version (Headscale 底层依赖这些进行 Hijack)
+		if req.Header.Get("Sec-WebSocket-Key") == "" {
+			req.Header.Set("Sec-WebSocket-Key", "dGhlIHNhbXBsZSBub25jZQ==")
+			req.Header.Set("Sec-WebSocket-Version", "13")
+		}
+
+		// 核心劫持：直接向后端写入原始 HTTP 请求（绕过 Go 默认 Transport 的限制）
+		if err := req.Write(backendConn); err != nil {
+			backendConn.Close()
+			return nil, err
+		}
+
+		// 从劫持后的连接中读取后端的 101 Switching Protocols 响应
+		br := bufio.NewReader(backendConn)
+		resp, err := http.ReadResponse(br, req)
+		if err != nil {
+			backendConn.Close()
+			return nil, err
+		}
+
+		// 强制标记为流式传输，阻止 Go 标准库尝试关闭连接或校验 Content-Length
+		resp.Close = false
+		resp.ContentLength = -1
+		resp.Header.Del("Content-Length")
+
+		// 包装全双工 Body，防止上层逻辑在 Body.Close 时误杀 backendConn
+		resp.Body = &readWriteCloseWrapper{
+			Reader: br,
+			Writer: backendConn,
+			Closer: io.NopCloser(br),
+		}
+		return resp, nil
+	}
+
 	return o.transport.RoundTrip(req)
 }
 
