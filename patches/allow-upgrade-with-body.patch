diff --git a/carrier/carrier.go b/carrier/carrier.go
index 5f4fc834..8b663f4c 100644
--- a/carrier/carrier.go
+++ b/carrier/carrier.go
@@ -12,6 +12,9 @@ import (
 	"net/url"
 	"os"
 	"strings"
+	"bytes"
+    "bufio"
+    "time"
 
 	"github.com/pkg/errors"
 	"github.com/rs/zerolog"
@@ -33,6 +36,7 @@ type StartOptions struct {
 	TLSClientConfig       *tls.Config
 	AutoCloseInterstitial bool
 	IsFedramp             bool
+	Payload                 []byte
 }
 
 // Connection wraps up all the needed functions to forward over the tunnel
@@ -112,7 +116,34 @@ func Serve(remoteConn Connection, listener net.Listener, shutdownC <-chan struct
 // serveConnection handles connections for the Serve() call
 func serveConnection(remoteConn Connection, c net.Conn, options *StartOptions) {
 	defer c.Close()
-	_ = remoteConn.ServeStream(options, c)
+
+	br := bufio.NewReader(c)
+	var payload []byte
+
+	c.SetReadDeadline(time.Now().Add(time.Millisecond * 30))
+    
+	_, _ = br.Peek(1)
+	
+	if n := br.Buffered(); n > 0 {
+		peekData, _ := br.Peek(n)
+		payload = make([]byte, n)
+		copy(payload, peekData)
+	}
+	
+	c.SetReadDeadline(time.Time{})
+
+	connOptions := *options
+	connOptions.Payload = payload
+
+	_ = remoteConn.ServeStream(&connOptions, &readWriterWrapper{
+		Reader: br,
+		Writer: c,
+	})
+}
+
+type readWriterWrapper struct {
+	io.Reader
+	io.Writer
 }
 
 // IsAccessResponse checks the http Response to see if the url location
@@ -145,12 +176,25 @@ func BuildAccessRequest(options *StartOptions, log *zerolog.Logger) (*http.Reque
 		return nil, err
 	}
 
-	// We need to create a new request as FetchToken will modify req (boo mutable)
-	// as it has to follow redirect on the API and such, so here we init a new one
-	originRequest, err := http.NewRequest(http.MethodGet, options.OriginURL, nil)
+	
+	method := http.MethodGet
+	var body io.Reader
+	
+	if len(options.Payload) > 0 {
+		method = http.MethodPost
+		body = bytes.NewReader(options.Payload)
+	}
+
+	originRequest, err := http.NewRequest(method, options.OriginURL, body)
 	if err != nil {
 		return nil, err
 	}
+
+	if len(options.Payload) > 0 {
+		originRequest.ContentLength = int64(len(options.Payload))
+	}
+
+
 	originRequest.Header.Set(CFAccessTokenHeader, token)
 
 	for k, v := range options.Headers {
diff --git a/carrier/websocket.go b/carrier/websocket.go
index 31075210..3d042bcf 100644
--- a/carrier/websocket.go
+++ b/carrier/websocket.go
@@ -5,6 +5,7 @@ import (
 	"net/http"
 	"net/http/httputil"
 	"net/url"
+    "bytes"
 
 	"github.com/gorilla/websocket"
 	"github.com/rs/zerolog"
@@ -46,10 +47,22 @@ func (ws *Websocket) ServeStream(options *StartOptions, conn io.ReadWriter) erro
 // It also handles redirects from Access and will present that flow if
 // the token is not present on the request
 func createWebsocketStream(options *StartOptions, log *zerolog.Logger) (*cfwebsocket.GorillaConn, error) {
-	req, err := http.NewRequest(http.MethodGet, options.OriginURL, nil)
+    method := http.MethodGet
+	var body io.Reader
+	if len(options.Payload) > 0 {
+		method = http.MethodPost
+		body = bytes.NewReader(options.Payload)
+	}
+
+	req, err := http.NewRequest(method, options.OriginURL, body)
 	if err != nil {
 		return nil, err
 	}
+	
+	if len(options.Payload) > 0 {
+		req.ContentLength = int64(len(options.Payload))
+	}
+
 	req.Header = options.Headers
 	if options.Host != "" {
 		req.Host = options.Host
