name: Build Cloudflared (Official Naming & Legacy Go)

on:
  workflow_dispatch:
    inputs:
      version:
        description: '发布版本号'
        required: true
        default: '2026.2.0'
      arch:
        description: '目标架构'
        required: true
        default: 'arm64'

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      # 1️⃣ 检出官方源码到主目录 (.)
      - name: Checkout cloudflared
        uses: actions/checkout@v4
        with:
          repository: cloudflare/cloudflared
          ref: ${{ github.event.inputs.version }}
          fetch-depth: 0

      # 2️⃣ 检出你自己的仓库到临时目录 (tmp_patches)
      - name: Checkout custom patches
        uses: actions/checkout@v4
        with:
          path: tmp_patches

      # 3️⃣ 应用补丁 (使用强制校验的 sed 注入)
      - name: Apply Headscale Patches
        run: |
          echo "=== 开始应用 Headscale 兼容性补丁 ==="

          # --- 1. 修改 connection/http2.go ---
          # 允许 101 状态码透传，不强制转为 200 (针对 RFC 7540 限制的绕过)
          # 使用更通用的匹配模式，防止空格干扰
          sed -i '/StatusSwitchingProtocols/,/status = http.StatusOK/d' connection/http2.go
          # 禁止删除 Upgrade 响应头
          sed -i '/func stripWebsocketUpgradeHeader(r \*http.Request) {/,/}/c\func stripWebsocketUpgradeHeader(r *http.Request) {\n\treturn\n}' connection/http2.go

          # --- 2. 修改 proxy/proxy.go ---
          # 恢复 WebSocket 握手阶段的 Body 和 ContentLength
          sed -i 's/roundTripReq.ContentLength = 0/roundTripReq.ContentLength = tr.Request.ContentLength/g' proxy/proxy.go
          sed -i 's/roundTripReq.Body = nil/roundTripReq.Body = tr.Request.Body/g' proxy/proxy.go
          
          # 在 RoundTrip 调用前清理干扰头 (使用单行替换模式，避免 YAML 多行缩进报错)
          # 我们直接替换这一行：resp, err := httpService.RoundTrip(roundTripReq)
          # 在它前面注入 Header 净化逻辑
          PATCH_LOGIC='if isWebsocket { roundTripReq.Header.Del("Cf-Cloudflared-Proxy-Connection-Upgrade"); roundTripReq.Header.Set("Connection", "Upgrade"); roundTripReq.Header.Set("Upgrade", "websocket"); } \n \t resp, err := httpService.RoundTrip(roundTripReq)'
          sed -i "s/resp, err := httpService.RoundTrip(roundTripReq)/$PATCH_LOGIC/" proxy/proxy.go

          # --- 3. 修改 carrier/websocket.go ---
          # 停止删除请求头中的 WebSocket 关键字段
          sed -i '/stripWebsocketHeaders/,/}/d' carrier/websocket.go

          echo "=== 补丁应用完成，开始验证 ==="
          
          # 强制校验：如果这几行报错，说明补丁没打进去，Action 会停止
          grep -q "roundTripReq.Body = tr.Request.Body" proxy/proxy.go || { echo "ERROR: proxy.go Body patch failed"; exit 1; }
          grep -q "Cf-Cloudflared-Proxy-Connection-Upgrade" proxy/proxy.go || { echo "ERROR: proxy.go Header patch failed"; exit 1; }
          grep -q "StatusSwitchingProtocols" connection/http2.go && { echo "ERROR: http2.go status patch failed"; exit 1; }
          
          echo "=== 校验通过！代码已就绪 ==="

      # 4️⃣ 安装环境依赖 (对齐 Makefile 需求)
      - name: Install System Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y make capnproto libcapnp-dev ruby ruby-dev rubygems build-essential rpm
          sudo gem install --no-document fpm

      # 5️⃣ 安装你指定的自定义 Legacy Go (解决 syscall 问题)
      - name: Install Your Custom Legacy Go
        run: |
          curl -L -o go.tar.gz https://github.com/yaoruisheng/go/releases/download/go-legacy-amd64-14/go-legacy-amd64.tar.gz
          mkdir -p $HOME/custom_go
          tar -xzf go.tar.gz -C $HOME/custom_go --strip-components=1
          echo "GOROOT=$HOME/custom_go" >> $GITHUB_ENV
          echo "PATH=$HOME/custom_go/bin:$PATH" >> $GITHUB_ENV

      # 6️⃣ 安装 Makefile 必需插件
      - name: Install Go Tools
        run: |
          go install capnproto.org/go/capnp/v3/capnpc-go@latest

      # 7️⃣ 编译与命名优化 (路径与你原始版本完全一致)
      - name: Build and Prepare Official Assets
        id: prep
        run: |
          VERSION=${{ github.event.inputs.version }}
          ARCH=${{ github.event.inputs.arch }}
          export GOOS=linux
          export GOARCH=$ARCH
          export CGO_ENABLED=0
          
          make cloudflared VERSION="$VERSION"
          make cloudflared-deb VERSION="$VERSION"
          
          BINARY_NAME="cloudflared-linux-$ARCH"
          mv cloudflared $BINARY_NAME
          
          DEB_TEMP=$(ls *.deb)
          DEB_NAME="cloudflared-linux-$ARCH.deb"
          mv "$DEB_TEMP" "$DEB_NAME"
          
          echo "BINARY=$BINARY_NAME" >> $GITHUB_OUTPUT
          echo "DEB=$DEB_NAME" >> $GITHUB_OUTPUT

      # 8️⃣ 发布到 GitHub Release
      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event.inputs.version }}
          name: ${{ github.event.inputs.version }}
          files: |
            ${{ steps.prep.outputs.BINARY }}
            ${{ steps.prep.outputs.DEB }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 9️⃣ 上传 Artifact 备份
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: cloudflared-build-${{ github.event.inputs.arch }}
          path: |
            ${{ steps.prep.outputs.BINARY }}
            ${{ steps.prep.outputs.DEB }}
